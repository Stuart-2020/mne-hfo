<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>mne_hfo.detect &#8212; mne_hfo 0.1.dev0 documentation</title>
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/gallery-rendered-html.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/style.css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js "></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          MNE-HFO</a>
        <span class="navbar-text navbar-version pull-left"><b>0.1.dev0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../whats_new.html">News</a></li>
                <li><a href="../../install.html">Install</a></li>
                <li><a href="../../tutorial.html">Tutorial</a></li>
                <li><a href="../../use.html">Use</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../contribute.html">Contribute!</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Useful Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="http://www.github.com/adam2392/mne-hfo/">mne-hfo &#64; GitHub</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/project/mne-hfo/">mne-hfo &#64; PyPI</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/adam2392/mne-hfo/issues">Issue Tracker</a></li>
</ul>
</ul>
</li>
              
            
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
<div class="navbar-form navbar-right navbar-btn dropdown btn-group-sm" style="margin-left: 20px; margin-top: 5px; margin-bottom: 5px">
  <button type="button" class="btn btn-primary navbar-btn dropdown-toggle" id="dropdownMenu1" data-toggle="dropdown">
    v0.1.dev0
    <span class="caret"></span>
  </button>
  <ul class="dropdown-menu" aria-labelledby="dropdownMenu1">
    <li><a href="https://mne-hfo.readthedocs.io/en/latest/index.html">Development</a></li>
    <li><a href="https://mne-hfo.readthedocs.io/en/stable/index.html">Stable</a></li>
    <li><a href="https://mne-hfo.readthedocs.io/en/v0.1/index.html">v0.1</a></li>
  </ul>
</div>


            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          

        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
      <div class="col-md-3">
        <div id="sidebar" class="bs-sidenav" role="complementary">
        </div>
      </div>
    <div class="body col-md-9 content" role="main">
      
  <h1>Source code for mne_hfo.detect</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">mne</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span><span class="p">,</span> <span class="n">cpu_count</span>
<span class="kn">from</span> <span class="nn">mne.utils</span> <span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">hilbert</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">mne_hfo.base</span> <span class="kn">import</span> <span class="n">Detector</span>
<span class="kn">from</span> <span class="nn">mne_hfo.config</span> <span class="kn">import</span> <span class="n">ACCEPTED_BAND_METHODS</span>
<span class="kn">from</span> <span class="nn">mne_hfo.posthoc</span> <span class="kn">import</span> <span class="n">_check_detection_overlap</span>


<span class="k">def</span> <span class="nf">_band_z_score_detect</span><span class="p">(</span><span class="n">x_cond</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">band_idx</span><span class="p">,</span> <span class="n">l_freq</span><span class="p">,</span> <span class="n">h_freq</span><span class="p">,</span>
                         <span class="n">cycle_threshold</span><span class="p">,</span> <span class="n">gap_threshold</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Iterate bandpass and z-score a channel&#39;s signal.</span>

<span class="sd">    Creates a bandpass filter (order=3) between ``l_freq`` and ``h_freq``.</span>
<span class="sd">    Then it z-scores the data</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x_cond :</span>
<span class="sd">    sfreq :</span>
<span class="sd">    band_idx :</span>
<span class="sd">    l_freq :</span>
<span class="sd">    h_freq :</span>
<span class="sd">    cycle_threshold :</span>
<span class="sd">    gap_threshold :</span>
<span class="sd">    threshold :</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tdetects : list of tuples</span>
<span class="sd">        All HFO events that passed the bandpass, zscore. It will store</span>
<span class="sd">        the band index (``band_idx``), timepoint of start, endpoint of start,</span>
<span class="sd">        and the maximum value of the Hilbert envelope in this event window.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tdetects</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># create highpass and lowpass filters</span>
    <span class="n">x_cond</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span>
        <span class="n">x_cond</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="n">sfreq</span><span class="p">,</span>
        <span class="n">l_freq</span><span class="o">=</span><span class="n">l_freq</span><span class="p">,</span> <span class="n">h_freq</span><span class="o">=</span><span class="n">h_freq</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;iir&#39;</span><span class="p">)</span>
    <span class="c1"># b, a = butter(N=3, Wn=l_freq / (sfreq / 2), btype=&#39;highpass&#39;)</span>
    <span class="c1"># x_cond = filtfilt(b, a, x_cond)</span>
    <span class="c1"># b, a = butter(N=3, Wn=h_freq / (sfreq / 2), btype=&#39;lowpass&#39;)</span>
    <span class="c1"># x_cond = filtfilt(b, a, x_cond)</span>

    <span class="c1"># Compute the z-scores</span>
    <span class="n">x_cond</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_cond</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x_cond</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">x_cond</span><span class="p">)</span>

    <span class="c1"># compute the absolute value of the Hilbert transform</span>
    <span class="c1"># (i.e. the envelope)</span>
    <span class="n">hfx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">hilbert</span><span class="p">(</span><span class="n">x_cond</span><span class="p">))</span>

    <span class="c1"># threshold the Hilbert envelope to create a</span>
    <span class="c1"># thresholded mask</span>
    <span class="n">thresh_sig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_cond</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">thresh_sig</span><span class="p">[</span><span class="n">hfx</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Now get the lengths of each detected HFO</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># indices where the threshold was met</span>
    <span class="n">thresh_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">thresh_sig</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gap_samp</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">gap_threshold</span> <span class="o">*</span> <span class="n">sfreq</span> <span class="o">/</span> <span class="n">l_freq</span><span class="p">)</span>

    <span class="c1"># loop through all significant zscore time points</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresh_idxs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresh_idxs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Move to the end of the detection</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">thresh_idxs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">stop_idx</span> <span class="o">=</span> <span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                        <span class="c1"># Check for number of cycles</span>
                        <span class="n">dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop_idx</span> <span class="o">-</span> <span class="n">start_idx</span><span class="p">)</span> <span class="o">/</span> <span class="n">sfreq</span>
                        <span class="n">cycs</span> <span class="o">=</span> <span class="n">l_freq</span> <span class="o">*</span> <span class="n">dur</span>
                        <span class="k">if</span> <span class="n">cycs</span> <span class="o">&gt;</span> <span class="n">cycle_threshold</span><span class="p">:</span>
                            <span class="c1"># Carry the amplitude and frequency info</span>
                            <span class="n">tdetects</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">band_idx</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">stop_idx</span><span class="p">,</span>
                                             <span class="nb">max</span><span class="p">(</span><span class="n">hfx</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">stop_idx</span><span class="p">])])</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># Check for gap</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">gap_samp</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stop_idx</span> <span class="o">=</span> <span class="n">thresh_idxs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                        <span class="c1"># Check for number of cycles</span>
                        <span class="n">dur</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop_idx</span> <span class="o">-</span> <span class="n">start_idx</span><span class="p">)</span> <span class="o">/</span> <span class="n">sfreq</span>
                        <span class="n">cycs</span> <span class="o">=</span> <span class="n">l_freq</span> <span class="o">*</span> <span class="n">dur</span>
                        <span class="k">if</span> <span class="n">cycs</span> <span class="o">&gt;</span> <span class="n">cycle_threshold</span><span class="p">:</span>
                            <span class="n">tdetects</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">band_idx</span><span class="p">,</span> <span class="n">start_idx</span><span class="p">,</span> <span class="n">stop_idx</span><span class="p">,</span>
                                             <span class="nb">max</span><span class="p">(</span><span class="n">hfx</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">stop_idx</span><span class="p">])])</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">tdetects</span>


<span class="k">def</span> <span class="nf">_run_detect_branch</span><span class="p">(</span><span class="n">detects</span><span class="p">,</span> <span class="n">det_idx</span><span class="p">,</span> <span class="n">HFO_outline</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Process detections from hilbert detector.</span>

<span class="sd">    HFO_outline structure:</span>
<span class="sd">    [0] - bands in which the detection happened</span>
<span class="sd">    [1] - starts for each band</span>
<span class="sd">    [2] - stop for each band</span>
<span class="sd">    [3] -</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">HFO_outline</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">detects</span><span class="p">[</span><span class="n">det_idx</span><span class="p">,</span> <span class="p">:]))</span>

    <span class="c1"># Create a subset for next band</span>
    <span class="n">next_band_idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">detects</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">detects</span><span class="p">[</span><span class="n">det_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">((</span><span class="n">next_band_idcs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="c1"># No detects in band - finish the branch</span>
        <span class="n">detects</span><span class="p">[</span><span class="n">det_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Set the processed detect to zero</span>
        <span class="k">return</span> <span class="n">HFO_outline</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Get overllaping detects</span>
        <span class="k">for</span> <span class="n">next_det_idx</span> <span class="ow">in</span> <span class="n">next_band_idcs</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">_check_detection_overlap</span><span class="p">([</span><span class="n">detects</span><span class="p">[</span><span class="n">det_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">detects</span><span class="p">[</span><span class="n">det_idx</span><span class="p">,</span>
                                                                      <span class="mi">2</span><span class="p">]],</span>
                                        <span class="p">[</span><span class="n">detects</span><span class="p">[</span><span class="n">next_det_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                         <span class="n">detects</span><span class="p">[</span><span class="n">next_det_idx</span><span class="p">,</span>
                                                 <span class="mi">2</span><span class="p">]]):</span>
                <span class="c1"># Go up the tree</span>
                <span class="n">_run_detect_branch</span><span class="p">(</span><span class="n">detects</span><span class="p">,</span> <span class="n">next_det_idx</span><span class="p">,</span> <span class="n">HFO_outline</span><span class="p">)</span>

        <span class="n">detects</span><span class="p">[</span><span class="n">det_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">HFO_outline</span>


<span class="k">class</span> <span class="nc">HilbertDetector</span><span class="p">(</span><span class="n">Detector</span><span class="p">):</span>  <span class="c1"># noqa</span>
    <span class="sd">&quot;&quot;&quot;2D HFO hilbert detection used in Kucewicz et al. 2014.</span>

<span class="sd">    A multi-taper method with: 4 Hz bandwidth, 1 sec sliding window,</span>
<span class="sd">    stepsize 100 ms, for the 1-500 Hz range, no padding, 2 tapers.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sfreq: float</span>
<span class="sd">        Sampling frequency of the signal</span>
<span class="sd">    l_freq: float</span>
<span class="sd">        Low cut-off frequency</span>
<span class="sd">    h_freq: float</span>
<span class="sd">        High cut-off frequency</span>
<span class="sd">    threshold: float</span>
<span class="sd">        Threshold for detection (default=3)</span>
<span class="sd">    band_method: str</span>
<span class="sd">        Spacing of hilbert frequency bands - options: &#39;linear&#39; or &#39;log&#39;</span>
<span class="sd">        (default=&#39;linear&#39;). Linear provides better frequency resolution but</span>
<span class="sd">        is slower.</span>
<span class="sd">    n_bands: int</span>
<span class="sd">        Number of bands if band_spacing = log (default=300)</span>
<span class="sd">    cycle_threshold: float</span>
<span class="sd">        Minimum number of cycles to detect (default=1)</span>
<span class="sd">    gap_threshold: float</span>
<span class="sd">        Number of cycles for gaps (default=1)</span>
<span class="sd">    n_jobs: int</span>
<span class="sd">        Number of cores to use (default=1)</span>
<span class="sd">    offset: int</span>
<span class="sd">        Offset which is added to the final detection. This is used when the</span>
<span class="sd">        function is run in separate windows. Default = 0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] M. T. Kucewicz, J. Cimbalnik, J. Y. Matsumoto, B. H. Brinkmann,</span>
<span class="sd">    M. Bower, V. Vasoli, V. Sulc, F. Meyer, W. R. Marsh, S. M. Stead, and</span>
<span class="sd">    G. A. Worrell, “High frequency oscillations are associated with</span>
<span class="sd">    cognitive processing in human recognition memory.,” Brain, pp. 1–14,</span>
<span class="sd">    Jun. 2014.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">l_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">h_freq</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                 <span class="n">threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">band_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                 <span class="n">n_bands</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">300</span><span class="p">,</span> <span class="n">cycle_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">gap_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                 <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scoring_func</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;f1&#39;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">band_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ACCEPTED_BAND_METHODS</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Band method </span><span class="si">{</span><span class="n">band_method</span><span class="si">}</span><span class="s1"> is not &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;an acceptable parameter. Please use &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;one of </span><span class="si">{</span><span class="n">ACCEPTED_BAND_METHODS</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">HilbertDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">threshold</span><span class="p">,</span> <span class="n">win_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">scoring_func</span><span class="o">=</span><span class="n">scoring_func</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span> <span class="o">=</span> <span class="n">sfreq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">l_freq</span> <span class="o">=</span> <span class="n">l_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h_freq</span> <span class="o">=</span> <span class="n">h_freq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">band_method</span> <span class="o">=</span> <span class="n">band_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_bands</span> <span class="o">=</span> <span class="n">n_bands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cycle_threshold</span> <span class="o">=</span> <span class="n">cycle_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gap_threshold</span> <span class="o">=</span> <span class="n">gap_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override ``Detector.fit`` function.&quot;&quot;&quot;</span>
        <span class="n">n_chs</span><span class="p">,</span> <span class="n">n_times</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># store all hfo occurrences as an array of channels X windows</span>
        <span class="n">n_windows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">n_times</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">win_size</span><span class="p">)</span> <span class="o">/</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">hfo_event_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_chs</span><span class="p">,</span> <span class="n">n_windows</span><span class="p">))</span>

        <span class="c1"># store contiguous hfos as one occurrence, so we store</span>
        <span class="c1"># them as a dictionary of lists</span>
        <span class="n">chs_hfos</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="c1"># bandpass the signal using FIR filter</span>
        <span class="c1"># X = mne.filter.filter_data(X, sfreq=self.sfreq,</span>
        <span class="c1">#                            l_freq=self.l_freq,</span>
        <span class="c1">#                            h_freq=self.h_freq, picks=picks,</span>
        <span class="c1">#                            method=&#39;iir&#39;, verbose=self.verbose)</span>

        <span class="c1"># Construct filter cut offs that are either logarithmically</span>
        <span class="c1"># or linearly spaced</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_method</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="n">low_fc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_freq</span><span class="p">)</span>
            <span class="n">high_fc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_freq</span><span class="p">)</span>
            <span class="n">freq_cutoffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">high_fc</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_bands</span><span class="p">)</span>
            <span class="n">freq_cutoffs</span> <span class="o">=</span> <span class="n">freq_cutoffs</span><span class="p">[(</span><span class="n">freq_cutoffs</span> <span class="o">&gt;</span> <span class="n">low_fc</span><span class="p">)</span> <span class="o">&amp;</span>
                                        <span class="p">(</span><span class="n">freq_cutoffs</span> <span class="o">&lt;</span> <span class="n">high_fc</span><span class="p">)]</span>
            <span class="n">freq_span</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freq_cutoffs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">band_method</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">freq_cutoffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">l_freq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_freq</span><span class="p">)</span>
            <span class="n">freq_span</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h_freq</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_freq</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># run detector on all channels</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chs</span><span class="p">):</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>

            <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># run detection algorithm possibly in parallel on this channel</span>
            <span class="n">tdetects_concat</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># for a single job, we don&#39;t need joblib</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>
                    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="kn">from</span> <span class="nn">sklearn.externals.joblib</span> <span class="kn">import</span> <span class="p">(</span>
                                <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
                            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;joblib not installed. &#39;</span>
                                 <span class="s1">&#39;Cannot run in parallel.&#39;</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Run the filters in their threads and return the result</span>
                <span class="n">iter_mat</span> <span class="o">=</span> <span class="p">[(</span><span class="n">sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
                             <span class="n">freq_cutoffs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                             <span class="n">freq_cutoffs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">cycle_threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap_threshold</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">freq_span</span><span class="p">)]</span>
                <span class="n">tdetects_concat</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)(</span>
                    <span class="n">delayed</span><span class="p">(</span><span class="n">_band_z_score_detect</span><span class="p">)(</span>
                        <span class="o">*</span><span class="n">iter_args</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">iter_args</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">iter_mat</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;HFO-first-phase&#39;</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># OPTIMIZE - check if there is a better way to do this</span>
                <span class="c1"># (S transform?+ spectra zeroing?)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">freq_span</span><span class="p">),</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;HFO-first-phase&#39;</span><span class="p">):</span>
                    <span class="n">bot</span> <span class="o">=</span> <span class="n">freq_cutoffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">freq_cutoffs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">sig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">bot</span><span class="p">,</span> <span class="n">top</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">cycle_threshold</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gap_threshold</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">]</span>

                    <span class="n">tdetects_concat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_band_z_score_detect</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

            <span class="c1"># post process detected HFO events by detecting outline of events</span>
            <span class="n">detects</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">det</span> <span class="k">for</span> <span class="n">band</span> <span class="ow">in</span> <span class="n">tdetects_concat</span>
                                <span class="k">for</span> <span class="n">det</span> <span class="ow">in</span> <span class="n">band</span><span class="p">])</span>
            <span class="n">outlines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">detects</span><span class="p">):</span>
                <span class="k">while</span> <span class="nb">sum</span><span class="p">(</span><span class="n">detects</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">det_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">detects</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">HFO_outline</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">outlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_run_detect_branch</span><span class="p">(</span><span class="n">detects</span><span class="p">,</span>
                                                                <span class="n">det_idx</span><span class="p">,</span>
                                                                <span class="n">HFO_outline</span><span class="p">)))</span>

            <span class="c1"># Get the detections</span>
            <span class="k">for</span> <span class="n">outline</span> <span class="ow">in</span> <span class="n">outlines</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">outline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outline</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">freq_min</span> <span class="o">=</span> <span class="n">freq_cutoffs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">outline</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>
                <span class="n">freq_max</span> <span class="o">=</span> <span class="n">freq_cutoffs</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">outline</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])]</span>
                <span class="n">frequency_at_max</span> <span class="o">=</span> <span class="n">freq_cutoffs</span><span class="p">[</span>
                    <span class="nb">int</span><span class="p">(</span><span class="n">outline</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">outline</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]),</span> <span class="mi">0</span><span class="p">])]</span>
                <span class="n">max_amplitude</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">outline</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span>

                <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span>
                               <span class="n">freq_min</span><span class="p">,</span> <span class="n">freq_max</span><span class="p">,</span> <span class="n">frequency_at_max</span><span class="p">,</span>
                               <span class="n">max_amplitude</span><span class="p">))</span>
            <span class="n">chs_hfos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hfo_event_arr_</span> <span class="o">=</span> <span class="n">hfo_event_arr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chs_hfos_</span> <span class="o">=</span> <span class="n">chs_hfos</span>
        <span class="k">return</span> <span class="n">chs_hfos</span>


<div class="viewcode-block" id="LineLengthDetector"><a class="viewcode-back" href="../../generated/mne_hfo.LineLengthDetector.html#mne_hfo.LineLengthDetector">[docs]</a><span class="k">class</span> <span class="nc">LineLengthDetector</span><span class="p">(</span><span class="n">Detector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Line-length detection algorithm.</span>

<span class="sd">    Original paper defines HFOS as &quot;(HFOs), which we collectively</span>
<span class="sd">    term as all activity &gt;40 Hz (including gamma, high-gamma,</span>
<span class="sd">    ripple, and fast ripple oscillations), may have a</span>
<span class="sd">    fundamental role in the generation and spread of focal seizures&quot;</span>

<span class="sd">    In the paper, data were sampled at 200 Hz and bandpass-filtered (0.1 – 100</span>
<span class="sd">    Hz) during acquisition. Data were further digitally bandpass-filtered</span>
<span class="sd">    (4th-order Butterworth, forward-backward filtering, ``0.1 – 85 Hz``)</span>
<span class="sd">    to minimize potential artifacts due to aliasing. (IIR for forward-backward</span>
<span class="sd">    pass).</span>

<span class="sd">    Compared to RMS detector, they utilize line-length metric.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filter_band : tuple(float, float) | None</span>
<span class="sd">        Low cut-off frequency at index 0 and high cut-off frequency</span>
<span class="sd">        at index 1.</span>
<span class="sd">    threshold: float</span>
<span class="sd">        Number of standard deviations to use as a threshold</span>
<span class="sd">    win_size: int</span>
<span class="sd">        Sliding window size in samples</span>
<span class="sd">    overlap: float</span>
<span class="sd">        Fraction of the window overlap (0 to 1)</span>
<span class="sd">    offset: int</span>
<span class="sd">        Offset which is added to the final detection. This is used when the</span>
<span class="sd">        function is run in separate windows. Default = 0</span>
<span class="sd">    hfo_name: str</span>
<span class="sd">        What to name the events detected (i.e. fast ripple if freq_band is</span>
<span class="sd">        (250, 500)).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For processing, a sliding window is used.</span>

<span class="sd">    For post-processing, any events that overlap are considered to be the same.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] A. B. Gardner, G. A. Worrell, E. Marsh, D. Dlugos, and B. Litt,</span>
<span class="sd">           “Human and automated detection of high-frequency oscillations in</span>
<span class="sd">           clinical intracranial EEG recordings,” Clin. Neurophysiol.,</span>
<span class="sd">           vol. 118, no. 5, pp. 1134–1143, May 2007.</span>
<span class="sd">    .. [2] Esteller, R. et al. (2001). Line length: an efficient feature for</span>
<span class="sd">           seizure onset detection. In Engineering in Medicine and Biology</span>
<span class="sd">           Society, 2001. Proceedings of the 23rd Annual International</span>
<span class="sd">           Conference of the IEEE (Vol. 2, pp. 1707-1710). IEEE.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">win_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                 <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">filter_band</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
                 <span class="n">scoring_func</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">hfo_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hfo&quot;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LineLengthDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">threshold</span><span class="p">,</span> <span class="n">win_size</span><span class="o">=</span><span class="n">win_size</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="n">overlap</span><span class="p">,</span>
            <span class="n">scoring_func</span><span class="o">=</span><span class="n">scoring_func</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span> <span class="o">=</span> <span class="n">filter_band</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span> <span class="o">=</span> <span class="n">sfreq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hfo_name</span> <span class="o">=</span> <span class="n">hfo_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lower frequency band for HFO definition.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">h_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Higher frequency band for HFO definition.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_hfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override ``Detector._compute_hfo`` function.&quot;&quot;&quot;</span>
        <span class="c1"># store all hfo occurrences as an array of channels X windows</span>
        <span class="n">n_windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_n_wins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">win_size</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">)</span>
        <span class="n">hfo_event_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chs</span><span class="p">,</span> <span class="n">n_windows</span><span class="p">))</span>

        <span class="c1"># bandpass the signal using FIR filter</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span><span class="p">,</span>
                                       <span class="n">l_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_freq</span><span class="p">,</span>
                                       <span class="n">h_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">h_freq</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;iir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># run HFO detection on all the channels</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chs</span><span class="p">)):</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># compute sliding window RMS</span>
                <span class="n">hfo_event_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sliding_window_detection</span><span class="p">(</span>
                        <span class="n">sig</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;line_length&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span>

            <span class="c1"># run joblib parallelization over channels</span>
            <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_sliding_window_detection</span><span class="p">)(</span>
                    <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;line_length&#39;</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chs</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)):</span>
                <span class="n">hfo_event_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">hfo_event_arr</span></div>


<div class="viewcode-block" id="RMSDetector"><a class="viewcode-back" href="../../generated/mne_hfo.RMSDetector.html#mne_hfo.RMSDetector">[docs]</a><span class="k">class</span> <span class="nc">RMSDetector</span><span class="p">(</span><span class="n">Detector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Root mean square (RMS) detection algorithm (Staba Detector).</span>

<span class="sd">    The original algorithm described in the reference, takes a sliding</span>
<span class="sd">    window of 3 ms, computes the RMS values between 100 and 500 Hz.</span>
<span class="sd">    Then events separated by less than 10 ms were combined into one event.</span>
<span class="sd">    Then events not having a minimum of 6 peaks (i.e. band-pass signal</span>
<span class="sd">    rectified above 0 V) with greater then 3 std above mean baseline</span>
<span class="sd">    were removed. A finite impulse response (FIR) filter with a</span>
<span class="sd">    Hamming window was used.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filter_band : tuple(float, float) | None</span>
<span class="sd">        Low cut-off frequency at index 0 and high cut-off frequency</span>
<span class="sd">        at index 1.</span>
<span class="sd">    threshold: float</span>
<span class="sd">        Number of standard deviations to use as a threshold.</span>
<span class="sd">        Default = 3.</span>
<span class="sd">    win_size: int</span>
<span class="sd">        Sliding window size in samples. Default = 100. The</span>
<span class="sd">        original paper uses a window size equivalent to 3 ms.</span>
<span class="sd">    overlap: float</span>
<span class="sd">        Fraction of the window overlap (0 to 1). Default = 0.25.</span>
<span class="sd">        The original paper uses an overlap of 0.</span>
<span class="sd">    offset: int</span>
<span class="sd">        Offset which is added to the final detection. This is used when the</span>
<span class="sd">        function is run in separate windows. Default = 0</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] R. J. Staba, C. L. Wilson, A. Bragin, I. Fried, and J. Engel,</span>
<span class="sd">    “Quantitative Analysis of High-Frequency Oscillations (80 − 500 Hz)</span>
<span class="sd">    Recorded in Human Epileptic Hippocampus and Entorhinal Cortex,”</span>
<span class="sd">    J. Neurophysiol., vol. 88, pp. 1743–1752, 2002.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">win_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                 <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.25</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filter_band</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">500</span><span class="p">),</span>
                 <span class="n">scoring_func</span><span class="o">=</span><span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">hfo_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;hfo&quot;</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RMSDetector</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">threshold</span><span class="p">,</span> <span class="n">win_size</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span>
            <span class="n">scoring_func</span><span class="p">,</span>
            <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># hyperparameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span> <span class="o">=</span> <span class="n">filter_band</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span> <span class="o">=</span> <span class="n">sfreq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hfo_name</span> <span class="o">=</span> <span class="n">hfo_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">l_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Lower frequency band for HFO definition.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">h_freq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Higher frequency band for HFO definition.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_band</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_compute_hfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override ``Detector._compute_hfo`` function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        hfo_event_arr : np.ndarray (channels x windows)</span>
<span class="sd">            The HFO metric value within each window per channel.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># store all hfo occurrences as an array of channels X windows</span>
        <span class="n">n_windows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_n_wins</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">win_size</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">step_size</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">n_times</span><span class="p">)</span>
        <span class="n">hfo_event_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chs</span><span class="p">,</span> <span class="n">n_windows</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">l_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_freq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># bandpass the signal using FIR filter</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">mne</span><span class="o">.</span><span class="n">filter</span><span class="o">.</span><span class="n">filter_data</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfreq</span><span class="p">,</span>
                                       <span class="n">l_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l_freq</span><span class="p">,</span>
                                       <span class="n">h_freq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">h_freq</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fir&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>

        <span class="c1"># run HFO detection on all the channels</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chs</span><span class="p">)):</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>

                <span class="c1"># compute sliding window RMS</span>
                <span class="n">hfo_event_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">_compute_sliding_window_detection</span><span class="p">(</span><span class="n">sig</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rms&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">n_jobs</span> <span class="o">=</span> <span class="n">cpu_count</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n_jobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span>

            <span class="n">results</span> <span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)(</span>
                <span class="n">delayed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_compute_sliding_window_detection</span><span class="p">)(</span>
                    <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:],</span> <span class="s1">&#39;rms&#39;</span>
                <span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_chs</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">)):</span>
                <span class="n">hfo_event_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">hfo_event_arr</span></div>
</pre></div>

    </div>
      
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2020-2021, MNE Developers. Last updated on 2021-02-25.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.1.<br/>
    </p>
  </div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-37225609-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-37225609-2');
</script>

  </body>
</html>